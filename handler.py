"""
RunPod Serverless Handler Template
Generated by Workflow-to-Endpoint System
"""
import runpod
import os
import websocket
import base64
import json
import uuid
import logging
import urllib.request
import urllib.parse
import binascii
import subprocess
import time

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

server_address = os.getenv('SERVER_ADDRESS', '127.0.0.1')
client_id = str(uuid.uuid4())

def queue_prompt(prompt):
    url = f"http://{server_address}:8188/prompt"
    p = {"prompt": prompt, "client_id": client_id}
    data = json.dumps(p).encode('utf-8')
    req = urllib.request.Request(url, data=data)
    return json.loads(urllib.request.urlopen(req).read())

def get_history(prompt_id):
    url = f"http://{server_address}:8188/history/{prompt_id}"
    with urllib.request.urlopen(url) as response:
        return json.loads(response.read())

def get_images(ws, prompt):
    prompt_id = queue_prompt(prompt)['prompt_id']
    output_images = {}
    while True:
        out = ws.recv()
        if isinstance(out, str):
            message = json.loads(out)
            if message['type'] == 'executing':
                data = message['data']
                if data['node'] is None and data['prompt_id'] == prompt_id:
                    break
        else:
            continue
    history = get_history(prompt_id)[prompt_id]
    for node_id in history['outputs']:
        node_output = history['outputs'][node_id]
        images_output = []
        if 'images' in node_output:
            for image in node_output['images']:
                with open(image['fullpath'], 'rb') as f:
                    image_data = base64.b64encode(f.read()).decode('utf-8')
                images_output.append(image_data)
        output_images[node_id] = images_output
    return output_images

def load_workflow(workflow_path):
    """Load workflow JSON file"""
    with open(workflow_path, 'r') as file:
        return json.load(file)

def download_file(url, output_path):
    result = subprocess.run(['wget', '-O', output_path, '--no-verbose', url], capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Download failed: {result.stderr}")
    return output_path

def save_base64_to_file(base64_data, temp_dir, output_filename):
    """Save base64 data to file"""
    try:
        decoded_data = base64.b64decode(base64_data)
        os.makedirs(temp_dir, exist_ok=True)
        file_path = os.path.abspath(os.path.join(temp_dir, output_filename))
        with open(file_path, 'wb') as f:
            f.write(decoded_data)
        logger.info(f"Saved base64 input to '{file_path}'")
        return file_path
    except (binascii.Error, ValueError) as e:
        logger.error(f"Base64 decoding failed: {e}")
        raise Exception(f"Base64 decoding failed: {e}")

def process_input(input_data, temp_dir, output_filename, input_type):
    """Process input data and return file path (path/url/base64)"""
    if input_type == "path":
        return input_data
    elif input_type == "url":
        os.makedirs(temp_dir, exist_ok=True)
        file_path = os.path.abspath(os.path.join(temp_dir, output_filename))
        return download_file(input_data, file_path)
    elif input_type == "base64":
        return save_base64_to_file(input_data, temp_dir, output_filename)
    else:
        raise Exception(f"Unsupported input type: {input_type}")

def get_image_input(job_input, task_id):
    """Extract image input from job_input (supports multiple formats)"""
    if "image_path" in job_input:
        return process_input(job_input["image_path"], task_id, "input_image.jpg", "path")
    elif "image_url" in job_input:
        return process_input(job_input["image_url"], task_id, "input_image.jpg", "url")
    elif "image_base64" in job_input:
        return process_input(job_input["image_base64"], task_id, "input_image.jpg", "base64")
    # Nested format (n8n/frontend compatibility)
    elif "images" in job_input and isinstance(job_input["images"], dict):
        images = job_input["images"]
        if images.get("input_image"):
            return process_input(images["input_image"], task_id, "input_image.jpg", "url")
        elif images.get("reference_image"):
            return process_input(images["reference_image"], task_id, "input_image.jpg", "url")
    return None

def get_output_images(images_dict, output_stage, stage1_node="12", final_node="16"):
    """Return images based on output_stage selection"""
    if output_stage == "both":
        result = {"images": {}}
        if stage1_node in images_dict and images_dict[stage1_node]:
            result["images"]["stage1"] = images_dict[stage1_node][0]
        if final_node in images_dict and images_dict[final_node]:
            result["images"]["final"] = images_dict[final_node][0]
        if not result["images"]:
            return {"error": "No image output found"}
        return result
    elif output_stage == "stage1":
        if stage1_node in images_dict and images_dict[stage1_node]:
            return {"image": images_dict[stage1_node][0]}
        return {"error": "Stage 1 image output not found"}
    else:  # "final" (default)
        if final_node in images_dict and images_dict[final_node]:
            return {"image": images_dict[final_node][0]}
        return {"error": "Final image output not found"}

def handler(job):
    job_input = job.get("input", {})
    logger.info(f"Job input: {job_input}")
    task_id = f"task_{uuid.uuid4()}"

    # Process image input
    image_path = get_image_input(job_input, task_id)
    if image_path is None:
        raise Exception("Image input is required. Provide image_path, image_url, or image_base64")

    # Load workflow JSON
    prompt = load_workflow('/XiCON_Poster_Maker_I2I_api.json')

    # Inject parameters into workflow nodes
    prompt["2"]["inputs"]["image"] = image_path

    # Stage 1 params
    prompt["11:74"]["inputs"]["text"] = job_input.get("prompt_stage1", prompt["11:74"]["inputs"]["text"])
    prompt["11:62"]["inputs"]["steps"] = int(job_input.get("steps", 20))
    prompt["11:63"]["inputs"]["cfg"] = float(job_input.get("cfg", 5))
    prompt["11:73"]["inputs"]["noise_seed"] = int(job_input.get("seed", 0))
    prompt["11:66"]["inputs"]["width"] = int(job_input.get("width", 1024))
    prompt["11:66"]["inputs"]["height"] = int(job_input.get("height", 1472))

    # Stage 2 params
    prompt["15:74"]["inputs"]["text"] = job_input.get("prompt_stage2", prompt["15:74"]["inputs"]["text"])
    prompt["15:62"]["inputs"]["steps"] = int(job_input.get("steps", 20))
    prompt["15:63"]["inputs"]["cfg"] = float(job_input.get("cfg", 5))
    prompt["15:73"]["inputs"]["noise_seed"] = int(job_input.get("seed", 0))

    # HTTP health check before WebSocket
    http_url = f"http://{server_address}:8188/"
    max_http_attempts = 180
    for http_attempt in range(max_http_attempts):
        try:
            urllib.request.urlopen(http_url, timeout=5)
            logger.info(f"HTTP connection successful (attempt {http_attempt+1})")
            break
        except Exception as e:
            if http_attempt == max_http_attempts - 1:
                raise Exception("Cannot connect to ComfyUI server.")
            time.sleep(1)

    # WebSocket connection with retry
    ws_url = f"ws://{server_address}:8188/ws?clientId={client_id}"
    ws = websocket.WebSocket()
    max_attempts = 36
    for attempt in range(max_attempts):
        try:
            ws.connect(ws_url)
            logger.info(f"WebSocket connection successful (attempt {attempt+1})")
            break
        except Exception as e:
            if attempt == max_attempts - 1:
                raise Exception("WebSocket connection timeout (3 minutes)")
            time.sleep(5)

    images = get_images(ws, prompt)
    ws.close()

    # Return result based on output_stage
    output_stage = job_input.get("output_stage", "final")
    return get_output_images(images, output_stage, stage1_node="12", final_node="16")

runpod.serverless.start({"handler": handler})
